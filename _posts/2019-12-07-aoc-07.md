---
title: "Advent of Code 2019-07 with R"
post_date: 2019-12-07
layout: single
permalink: /aoc-2019-07/
categories:
  - r-blog-en
  - aoc
output: jekyllthat::jekylldown
excerpt_separator: <!--more-->
---

Solving Advent of Code 2019-07 with R.

\[Disclaimer\] Obviously, this post contains a big spoiler about Advent
of Code, as it gives solutions for solving day 7.

## Instructions

Find the instructions at: <https://adventofcode.com/2019/day/7>

## R solution

``` r
vec <- scan("input7.txt", numeric(), sep = ",")

# Getting parse_opcode
source("intcode_helpers.R")

prog <- function(vec, inputs, pos = 1){
  ipt_stat <- 1
  stock <- 1
  while (pos < length(vec)) {

    c(op_code, one, two, three) %<-%  parse_opcode( vec,  pos )

    if (op_code == 99) {
      return(
        list(
          vec = vec,
          res = res,
          pos = pos,
          code = 99,
          processed = FALSE
        )
      )
    }

    if (op_code %in% 1:2){

      if (op_code == 1) fun <- `+`
      if (op_code == 2) fun <- `*`
      vec[three] <- fun(one, two)
      pos <- pos + 4
    } else if (op_code == 3){
      if (stock > length(inputs)){
        return(
          list(
            vec = vec,
            res = res,
            pos = pos,
            code = op_code,
            processed = TRUE
          )
        )
      }
      if (ipt_stat == 1){
        vec[ vec[pos + 1] + 1 ] <- inputs[1]
        ipt_stat <- 2
      } else {
        vec[ vec[pos + 1] + 1 ] <- inputs[2]
      }
      pos <- pos + 2
      stock <- stock + 1
    } else if (op_code == 4){
      res <- vec[vec[pos + 1] + 1]
      pos <- pos + 2
    } else if (op_code == 5){
      if (one != 0){
        pos <- two + 1
      } else {
        pos <- pos + 3
      }
    } else if (op_code == 6){
      if (one == 0){
        pos <- two + 1
      } else {
        pos <- pos + 3
      }
    } else if (op_code == 7){
      if (one < two){
        vec[three] <- 1
      } else {
        vec[three] <- 0
      }
      pos <- pos + 4
    } else if (op_code == 8){
      if (one == two){
        vec[three] <- 1
      } else {
        vec[three] <- 0
      }
      pos <- pos + 4
    }
  }
  return(
    list(
      vec = vec,
      res = res,
      pos = pos,
      code = op_code,
      processed = FALSE
    )
  )
}

res <- 0

comb <-  expand.grid(0:4, 0:4, 0:4, 0:4, 0:4)

to_keep <-  apply(comb, 1, function(x){
  length(unique(x)) != length(x)
})

comb <- comb[!to_keep, ]
for (i in seq_len(nrow(comb))){
  phase <- comb[i, ] %>% as.numeric()
  start <- 0
  for (j in seq_along(phase)){
    start <- prog(vec, c(phase[j], start))$res
  }
  res[i] <- start
}
max(res)
```

    ## [1] 67023

### Part two

``` r
library(purrr)
```

    ##
    ## Attaching package: 'purrr'

    ## The following object is masked from 'package:magrittr':
    ##
    ##     set_names

``` r
res <- 0

comb <-  expand.grid(5:9, 5:9, 5:9, 5:9, 5:9)

to_keep <-  apply(comb, 1, function(x){
  length(unique(x)) != length(x)
})
comb <- comb[!to_keep, ]

for (i in seq_len(nrow(comb))){
  phase <- comb[i, ] %>% as.numeric()

  A <- prog(vec, c(phase[1], 0))
  B <- prog(vec, c(phase[2], A$res))
  C <- prog(vec, c(phase[3], B$res))
  D <- prog(vec, c(phase[4], C$res))
  E <- prog(vec, c(phase[5], D$res))

  while(
    map_lgl(
      list(A, B, C, D, E),
      "processed"
    ) %>% all()
  ){
    A <- prog(A$vec, E$res, pos = A$pos)
    B <- prog(B$vec, A$res, pos = B$pos)
    C <- prog(C$vec, B$res, pos = C$pos)
    D <- prog(D$vec, C$res, pos = D$pos)
    E <- prog(E$vec, D$res, pos = E$pos)
  }

  res[i] <- E$res
}
max(res)
```

    ## [1] 7818398
