<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>R Internals</title>
  <meta name="description" content="R Internals: a guide to the internal structures of R and coding standards for the core team working on R itself.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="R Internals" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="R Internals: a guide to the internal structures of R and coding standards for the core team working on R itself." />
  <meta name="github-repo" content="ColinFay/r-internals" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="R Internals" />
  
  <meta name="twitter:description" content="R Internals: a guide to the internal structures of R and coding standards for the core team working on R itself." />
  

<meta name="author" content="R Core Team">


<meta name="date" content="2017-10-18">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="files.html">
<link rel="next" href="gui-consoles.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-65307055-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-65307055-3');
</script>



<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">R internals</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>R Internals</a></li>
<li class="chapter" data-level="1" data-path="r-internal-structures.html"><a href="r-internal-structures.html"><i class="fa fa-check"></i><b>1</b> R Internal Structures</a></li>
<li class="chapter" data-level="2" data-path="internal-vs-primitive.html"><a href="internal-vs-primitive.html"><i class="fa fa-check"></i><b>2</b> <code class="calibre18">.Internal</code> vs <code class="calibre18">.Primitive</code></a></li>
<li class="chapter" data-level="3" data-path="internationalization-in-the-r-sources.html"><a href="internationalization-in-the-r-sources.html"><i class="fa fa-check"></i><b>3</b> Internationalization in the R sources</a></li>
<li class="chapter" data-level="4" data-path="structure-of-an-installed-package.html"><a href="structure-of-an-installed-package.html"><i class="fa fa-check"></i><b>4</b> Structure of an Installed Package</a></li>
<li class="chapter" data-level="5" data-path="files.html"><a href="files.html"><i class="fa fa-check"></i><b>5</b> Files</a></li>
<li class="chapter" data-level="6" data-path="graphics.html"><a href="graphics.html"><i class="fa fa-check"></i><b>6</b> Graphics</a></li>
<li class="chapter" data-level="7" data-path="gui-consoles.html"><a href="gui-consoles.html"><i class="fa fa-check"></i><b>7</b> GUI consoles</a></li>
<li class="chapter" data-level="8" data-path="tools.html"><a href="tools.html"><i class="fa fa-check"></i><b>8</b> Tools</a></li>
<li class="chapter" data-level="9" data-path="r-coding-standards.html"><a href="r-coding-standards.html"><i class="fa fa-check"></i><b>9</b> R coding standards</a></li>
<li class="chapter" data-level="10" data-path="testing-r-code.html"><a href="testing-r-code.html"><i class="fa fa-check"></i><b>10</b> Testing R code</a></li>
<li class="chapter" data-level="11" data-path="use-of-tex-dialects.html"><a href="use-of-tex-dialects.html"><i class="fa fa-check"></i><b>11</b> Use of TeX dialects</a></li>
<li class="chapter" data-level="12" data-path="current-and-future-directions.html"><a href="current-and-future-directions.html"><i class="fa fa-check"></i><b>12</b> Current and future directions</a></li>
<li class="chapter" data-level="13" data-path="function-and-variable-index.html"><a href="function-and-variable-index.html"><i class="fa fa-check"></i><b>13</b> Function and variable index</a></li>
<li class="chapter" data-level="14" data-path="concept-index.html"><a href="concept-index.html"><i class="fa fa-check"></i><b>14</b> Concept index</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
<li><a href="https://github.com/ColinFay" target="blank">Adapted by Colin Fay</a></li>
<li><a href="https://cran.r-project.org/manuals.html" target="blank">from the R manuals</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R Internals</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="graphics" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Graphics</h1>
<p>
R’s graphics internals were re-designed to enable multiple graphics systems to be installed on top on the graphics ‘engine’ – currently there are two such systems, one supporting ‘base’ graphics (based on that in S and whose R code<a href="concept-index.html#FOOT15" id="DOCF15"><sup>15</sup></a> is in package <strong>graphics</strong>) and one implemented in package <strong>grid</strong>.
</p>
<p>
Some notes on the historical changes can be found at <a href="https://www.stat.auckland.ac.nz/~paul/R/basegraph.html" class="uri">https://www.stat.auckland.ac.nz/~paul/R/basegraph.html</a> and <a href="https://www.stat.auckland.ac.nz/~paul/R/graphicsChanges.html" class="uri">https://www.stat.auckland.ac.nz/~paul/R/graphicsChanges.html</a>.
</p>
<p>
At the lowest level is a graphics device, which manages a plotting surface (a screen window or a representation to be written to a file). This implements a set of graphics primitives, to ‘draw’
</p>
<ul>
<li>
a circle, optionally filled
</li>
<li>
a rectangle, optionally filled
</li>
<li>
a line
</li>
<li>
a set of connected lines
</li>
<li>
a polygon, optionally filled
</li>
<li>
a paths, optionally filled using a winding rule
</li>
<li>
text
</li>
<li>
a raster image (optional)
</li>
<li>
and to set a clipping rectangle
</li>
</ul>
<p>
as well as requests for information such as
</p>
<ul>
<li>
the width of a string if plotted
</li>
<li>
the metrics (width, ascent, descent) of a single character
</li>
<li>
the current size of the plotting surface
</li>
</ul>
<p>
and requests/opportunities to take action such as
</p>
<ul>
<li>
start a new ‘page’, possibly after responding to a request to ask the user for confirmation.
</li>
<li>
return the position of the device pointer (if any).
</li>
<li>
when a device become the current device or stops being the current device (this is usually used to change the window title on a screen device).
</li>
<li>
when drawing starts or finishes (e.g. used to flush graphics to the screen when drawing stops).
</li>
<li>
wait for an event, for example a mouse click or keypress.
</li>
<li>
an ‘onexit’ action, to clean up if plotting is interrupted (by an error or by the user).
</li>
<li>
capture the current contents of the device as a raster image.
</li>
<li>
close the device.
</li>
</ul>
<p>
The device also sets a number of variables, mainly Boolean flags indicating its capabilities. Devices work entirely in ‘device units’ which are up to its developer: they can be in pixels, big points (1/72 inch), twips, …, and can differ<a href="concept-index.html#FOOT16" id="DOCF16"><sup>16</sup></a> in the ‘x’ and ‘y’ directions.
</p>
<p>
The next layer up is the graphics ‘engine’ that is the main interface to the device (although the graphics subsystems do talk directly to devices). This is responsible for clipping lines, rectangles and polygons, converting the <code class="calibre2">pch</code> values <code class="calibre2">0…26</code> to sets of lines/circles, centring (and otherwise adjusting) text, rendering mathematical expressions (‘plotmath’) and mapping colour descriptions such as names to the internal representation.
</p>
<p>
Another function of the engine is to manage display lists and snapshots. Some but not all instances of graphics devices maintain display lists, a ‘list’ of operations that have been performed on the device to produce the current plot (since the device was opened or the plot was last cleared, e.g. by <code class="calibre2">plot.new</code>). Screen devices generally maintain a display list to handle repaint and resize events whereas file-based formats do not—display lists are also used to implement <code class="calibre2">dev.copy()</code> and friends. The display list is a pairlist of <code class="calibre2">.Internal</code> (base graphics) or <code class="calibre2">.Call.graphics</code> (grid graphics) calls, which means that the C code implementing a graphics operation will be re-called when the display list is replayed: apart from the part which records the operation if successful.
</p>
<p>
Snapshots of the current graphics state are taken by <code class="calibre2">GEcreateSnapshot</code> and replayed later in the session by <code class="calibre2">GEplaySnapshot</code>. These are used by <code class="calibre2">recordPlot()</code>, <code class="calibre2">replayPlot()</code> and the GUI menus of the <code class="calibre2">windows()</code> device. The ‘state’ includes the display list.
</p>
<p>
The top layer comprises the graphics subsystems. Although there is provision for 24 subsystems since about 2001, currently still only two exist, ‘base’ and ‘grid’. The base subsystem is registered with the engine when R is initialized, and unregistered (via <code class="calibre2">KillAllDevices</code>) when an R session is shut down. The grid subsystem is registered in its <code class="calibre2">.onLoad</code> function and unregistered in the <code class="calibre2">.onUnload</code> function. The graphics subsystem may also have ‘state’ information saved in a snapshot (currently base does and grid does not).
</p>
<p>
Package <strong>grDevices</strong> was originally created to contain the basic graphics devices (although <code class="calibre2">X11</code> is in a separate load-on-demand module because of the volume of external libraries it brings in). Since then it has been used for other functionality that was thought desirable for use with <strong>grid</strong>, and hence has been transferred from package <strong>graphics</strong> to <strong>grDevices</strong>. This is principally concerned with the handling of colours and recording and replaying plots.
</p>
<hr />
<p>
<a href="" id="Graphics-devices"></a> <a href="" id="Graphics-Devices-1"></a>
</p>
<h3 id="graphics-devices" class="section">
6.1 Graphics Devices
</h3>
<p>
R ships with several graphics devices, and there is support for third-party packages to provide additional devices—several packages now do. This section describes the device internals from the viewpoint of a would-be writer of a graphics device.
</p>
<hr />
<p>
<a href="" id="Device-structures"></a> <a href="" id="Device-structures-1"></a>
</p>
<h4 id="device-structures" class="subsection">
6.1.1 Device structures
</h4>
<p>
There are two types used internally which are pointers to structures related to graphics devices.
</p>
<p>
The <code class="calibre2">DevDesc</code> type is a structure defined in the header file R_ext/GraphicsDevice.h (which is included by R_ext/GraphicsEngine.h). This describes the physical characteristics of a device, the capabilities of the device driver and contains a set of callback functions that will be used by the graphics engine to obtain information about the device and initiate actions (e.g. a new page, plotting a line or some text). Type <code class="calibre2">pDevDesc</code> is a pointer to this type.
</p>
<p>
The following callbacks can be omitted (or set to the null pointer, their default value) when appropriate default behaviour will be taken by the graphics engine: <code class="calibre2">activate</code>, <code class="calibre2">cap</code>, <code class="calibre2">deactivate</code>, <code class="calibre2">locator</code>, <code class="calibre2">holdflush</code> (API version 9), <code class="calibre2">mode</code>, <code class="calibre2">newFrameConfirm</code>, <code class="calibre2">path</code>, <code class="calibre2">raster</code> and <code class="calibre2">size</code>.
</p>
<p>
The relationship of device units to physical dimensions is set by the element <code class="calibre2">ipr</code> of the <code class="calibre2">DevDesc</code> structure: a ‘double’ array of length 2.
</p>
<p>
The <code class="calibre2">GEDevDesc</code> type is a structure defined in R_ext/GraphicsEngine.h (with comments in the file) as
</p>
<div class="example">
<pre class="example1"><code>typedef struct _GEDevDesc GEDevDesc;
struct _GEDevDesc {
    pDevDesc dev;
    Rboolean displayListOn;
    SEXP displayList;
    SEXP DLlastElt;
    SEXP savedSnapshot;
    Rboolean dirty;
    Rboolean recordGraphics;
    GESystemDesc *gesd[MAX_GRAPHICS_SYSTEMS];
    Rboolean ask;
}</code></pre>
</div>
<p>
So this is essentially a device structure plus information about the device maintained by the graphics engine and normally<a href="concept-index.html#FOOT17" id="DOCF17"><sup>17</sup></a> visible to the engine and not to the device. Type <code class="calibre2">pGEDevDesc</code> is a pointer to this type.
</p>
<p>
The graphics engine maintains an array of devices, as pointers to <code class="calibre2">GEDevDesc</code> structures. The array is of size 64 but the first element is always occupied by the <code class="calibre2">“null device”</code> and the final element is kept as NULL as a sentinel.<a href="concept-index.html#FOOT18" id="DOCF18"><sup>18</sup></a> This array is reflected in the R variable ‘.Devices’. Once a device is killed its element becomes available for reallocation (and its name will appear as <code class="calibre2">“”</code> in ‘.Devices’). Exactly one of the devices is ‘active’: this is the the null device if no other device has been opened and not killed.
</p>
<p>
Each instance of a graphics device needs to set up a <code class="calibre2">GEDevDesc</code> structure by code very similar to
</p>
<div class="example">
<pre class="example1"><code>    pGEDevDesc gdd;

    R_GE_checkVersionOrDie(R_GE_version);
    R_CheckDeviceAvailable();
    BEGIN_SUSPEND_INTERRUPTS {
        pDevDesc dev;
        /* Allocate and initialize the device driver data */
        if (!(dev = (pDevDesc) calloc(1, sizeof(DevDesc))))
            return 0; /* or error() */
        /* set up device driver or free ‘dev’ and error() */
        gdd = GEcreateDevDesc(dev);
        GEaddDevice2(gdd, &quot;dev_name&quot;);
    } END_SUSPEND_INTERRUPTS;</code></pre>
</div>
<p>
The <code class="calibre2">DevDesc</code> structure contains a <code class="calibre2">void *</code> pointer ‘deviceSpecific’ which is used to store data specific to the device. Setting up the device driver includes initializing all the non-zero elements of the <code class="calibre2">DevDesc</code> structure.
</p>
<p>
Note that the device structure is zeroed when allocated: this provides some protection against future expansion of the structure since the graphics engine can add elements that need to be non-NULL/non-zero to be ‘on’ (and the structure ends with 64 reserved bytes which will be zeroed and allow for future expansion).
</p>
<p>
Rather more protection is provided by the version number of the engine/device API, <code class="calibre2">R_GE_version</code> defined in R_ext/GraphicsEngine.h together with access functions
</p>
<div class="example">
<pre class="example1"><code>int R_GE_getVersion(void);
void R_GE_checkVersionOrDie(int version);</code></pre>
</div>
<p>
If a graphics device calls <code class="calibre2">R_GE_checkVersionOrDie(R_GE_version)</code> it can ensure it will only be used in versions of R which provide the API it was designed for and compiled against.
</p>
<hr />
<p>
<a href="" id="Device-capabilities"></a> <a href="" id="Device-capabilities-1"></a>
</p>
<h4 id="device-capabilities" class="subsection">
6.1.2 Device capabilities
</h4>
<p>
The following ‘capabilities’ can be defined for the device’s <code class="calibre2">DevDesc</code> structure.
</p>
<ul>
<li>
<code class="calibre2">canChangeGamma</code> – <code class="calibre2">Rboolean</code>: can the display gamma be adjusted? This is now ignored, as gamma support has been removed.
</li>
<li>
<code class="calibre2">canHadj</code> – <code class="calibre2">integer</code>: can the device do horizontal adjustment of text <em>via</em> the <code class="calibre2">text</code> callback, and if so, how precisely? 0 = no adjustment, 1 = {0, 0.5, 1} (left, centre, right justification) or 2 = continuously variable (in [0,1]) between left and right justification.
</li>
<li>
<code class="calibre2">canGenMouseDown</code> – <code class="calibre2">Rboolean</code>: can the device handle mouse down events? This flag and the next three are not currently used by R, but are maintained for back compatibility.
</li>
<li>
<code class="calibre2">canGenMouseMove</code> – <code class="calibre2">Rboolean</code>: ditto for mouse move events.
</li>
<li>
<code class="calibre2">canGenMouseUp</code> – <code class="calibre2">Rboolean</code>: ditto for mouse up events.
</li>
<li>
<code class="calibre2">canGenKeybd</code> – <code class="calibre2">Rboolean</code>: ditto for keyboard events.
</li>
<li>
<code class="calibre2">hasTextUTF8</code> – <code class="calibre2">Rboolean</code>: should non-symbol text be sent (in UTF-8) to the <code class="calibre2">textUTF8</code> and <code class="calibre2">strWidthUTF8</code> callbacks, and sent as Unicode points (negative values) to the <code class="calibre2">metricInfo</code> callback?
</li>
<li>
<code class="calibre2">wantSymbolUTF8</code> – <code class="calibre2">Rboolean</code>: should symbol text be handled in UTF-8 in the same way as other text? Requires <code class="calibre2">textUTF8 = TRUE</code>.
</li>
<li>
<code class="calibre2">haveTransparency</code>: does the device support semi-transparent colours?
</li>
<li>
<code class="calibre2">haveTransparentBg</code>: can the background be fully or semi-transparent?
</li>
<li>
<code class="calibre2">haveRaster</code>: is there support for rendering raster images?
</li>
<li>
<code class="calibre2">haveCapture</code>: is there support for <code class="calibre2">grid::grid.cap</code>?
</li>
<li>
<code class="calibre2">haveLocator</code>: is there an interactive locator?
</li>
</ul>
<p>
The last three can often be deduced to be false from the presence of <code class="calibre2">NULL</code> entries instead of the corresponding functions.
</p>
<hr />
<p>
<a href="" id="Handling-text"></a> <a href="" id="Handling-text-1"></a>
</p>
<h4 id="handling-text" class="subsection">
6.1.3 Handling text
</h4>
<p>
Handling text is probably the hardest task for a graphics device, and the design allows for the device to optionally indicate that it has additional capabilities. (If the device does not, these will if possible be handled in the graphics engine.)
</p>
<p>
The three callbacks for handling text that must be in all graphics devices are <code class="calibre2">text</code>, <code class="calibre2">strWidth</code> and <code class="calibre2">metricInfo</code> with declarations
</p>
<div class="example">
<pre class="example1"><code>void text(double x, double y, const char *str, double rot, double hadj,
          pGgcontext gc, pDevDesc dd);

double strWidth(const char *str, pGEcontext gc, pDevDesc dd);

void metricInfo(int c, pGEcontext gc,
               double* ascent, double* descent, double* width,
               pDevDesc dd);</code></pre>
</div>
<p>
The ‘gc’ parameter provides the graphics context, most importantly the current font and fontsize, and ‘dd’ is a pointer to the active device’s structure.
</p>
<p>
The <code class="calibre2">text</code> callback should plot ‘str’ at ‘(x, y)’<a href="concept-index.html#FOOT19" id="DOCF19"><sup>19</sup></a> with an anti-clockwise rotation of ‘rot’ degrees. (For ‘hadj’ see below.) The interpretation for horizontal text is that the baseline is at <code class="calibre2">y</code> and the start is a <code class="calibre2">x</code>, so any left bearing for the first character will start at <code class="calibre2">x</code>.
</p>
<p>
The <code class="calibre2">strWidth</code> callback computes the width of the string which it would occupy if plotted horizontally in the current font. (Width here is expected to include both (preferably) or neither of left and right bearings.)
</p>
<p>
The <code class="calibre2">metricInfo</code> callback computes the size of a single character: <code class="calibre2">ascent</code> is the distance it extends above the baseline and <code class="calibre2">descent</code> how far it extends below the baseline. <code class="calibre2">width</code> is the amount by which the cursor should be advanced when the character is placed. For <code class="calibre2">ascent</code> and <code class="calibre2">descent</code> this is intended to be the bounding box of the ‘ink’ put down by the glyph and not the box which might be used when assembling a line of conventional text (it needs to be for e.g. <code class="calibre2">hat(beta)</code> to work correctly). However, the <code class="calibre2">width</code> is used in plotmath to advance to the next character, and so needs to include left and right bearings.
</p>
<p>
The <em>interpretation</em> of ‘c’ depends on the locale. In a single-byte locale values <code class="calibre2">32…255</code> indicate the corresponding character in the locale (if present). For the symbol font (as used by ‘graphics::par(font=5)’, ‘grid::gpar(fontface=5’) and by ‘plotmath’), values <code class="calibre2">32…126, 161…239, 241…254</code> indicate glyphs in the Adobe Symbol encoding. In a multibyte locale, <code class="calibre2">c</code> represents a Unicode point (except in the symbol font). So the function needs to include code like
</p>
<div class="example">
<pre class="example1"><code>    Rboolean Unicode = mbcslocale &amp;&amp; (gc-&gt;fontface != 5);
    if (c &lt; 0) { Unicode = TRUE; c = -c; }
    if(Unicode) UniCharMetric(c, ...); else CharMetric(c, ...);</code></pre>
</div>
<p>
In addition, if device capability <code class="calibre2">hasTextUTF8</code> (see below) is true, Unicode points will be passed as negative values: the code snippet above shows how to handle this. (This applies to the symbol font only if device capability <code class="calibre2">wantSymbolUTF8</code> is true.)
</p>
<p>
If possible, the graphics device should handle clipping of text. It indicates this by the structure element <code class="calibre2">canClip</code> which if true will result in calls to the callback <code class="calibre2">clip</code> to set the clipping region. If this is not done, the engine will clip very crudely (by omitting any text that does not appear to be wholly inside the clipping region).
</p>
<p>
The device structure has an integer element <code class="calibre2">canHadj</code>, which indicates if the device can do horizontal alignment of text. If this is one, argument ‘hadj’ to <code class="calibre2">text</code> will be called as <code class="calibre2">0 ,0.5, 1</code> to indicate left-, centre- and right-alignment at the indicated position. If it is two, continuous values in the range <code class="calibre2">[0, 1]</code> are assumed to be supported.
</p>
<p>
Capability <code class="calibre2">hasTextUTF8</code> if true, it has two consequences. First, there are callbacks <code class="calibre2">textUTF8</code> and <code class="calibre2">strWidthUTF8</code> that should behave identically to <code class="calibre2">text</code> and <code class="calibre2">strWidth</code> except that ‘str’ is assumed to be in UTF-8 rather than the current locale’s encoding. The graphics engine will call these for all text except in the symbol font. Second, Unicode points will be passed to the <code class="calibre2">metricInfo</code> callback as negative integers. If your device would prefer to have UTF-8-encoded symbols, define <code class="calibre2">wantSymbolUTF8</code> as well as <code class="calibre2">hasTextUTF8</code>. In that case text in the symbol font is sent to <code class="calibre2">textUTF8</code> and <code class="calibre2">strWidthUTF8</code>.
</p>
<p>
Some devices can produce high-quality rotated text, but those based on bitmaps often cannot. Those which can should set <code class="calibre2">useRotatedTextInContour</code> to be true from graphics API version 4.
</p>
<p>
Several other elements relate to the precise placement of text by the graphics engine:
</p>
<div class="example">
<pre class="example1"><code>double xCharOffset;
double yCharOffset;
double yLineBias;
double cra[2];</code></pre>
</div>
<p>
These are more than a little mysterious. Element <code class="calibre2">cra</code> provides an indication of the character size, <code class="calibre2">par(“cra”)</code> in base graphics, in device units. The mystery is what is meant by ‘character size’: which character, which font at which size? Some help can be obtained by looking at what this is used for. The first element, ‘width’, is not used by R except to set the graphical parameters. The second, ‘height’, is use to set the line spacing, that is the relationship between <code class="calibre2">par(“mai”)</code> and <code class="calibre2">par(“mai”)</code> and so on. It is suggested that a good choice is
</p>
<div class="example">
<pre class="example1"><code>dd-&gt;cra[0] = 0.9 * fnsize;
dd-&gt;cra[1] = 1.2 * fnsize;</code></pre>
</div>
<p>
where ‘fnsize’ is the ‘size’ of the standard font (<code class="calibre2">cex=1</code>) on the device, in device units. So for a 12-point font (the usual default for graphics devices), ‘fnsize’ should be 12 points in device units.
</p>
<p>
The remaining elements are yet more mysterious. The <code class="calibre2">postscript()</code> device says
</p>
<div class="example">
<pre class="example1"><code>    /* Character Addressing Offsets */
    /* These offsets should center a single */
    /* plotting character over the plotting point. */
    /* Pure guesswork and eyeballing ... */

    dd-&gt;xCharOffset =  0.4900;
    dd-&gt;yCharOffset =  0.3333;
    dd-&gt;yLineBias = 0.2;</code></pre>
</div>
<p>
It seems that <code class="calibre2">xCharOffset</code> is not currently used, and <code class="calibre2">yCharOffset</code> is used by the base graphics system to set vertical alignment in <code class="calibre2">text()</code> when <code class="calibre2">pos</code> is specified, and in <code class="calibre2">identify()</code>. It is occasionally used by the graphic engine when attempting exact centring of text, such as character string values of <code class="calibre2">pch</code> in <code class="calibre2">points()</code> or <code class="calibre2">grid.points()</code>—however, it is only used when precise character metric information is not available or for multi-line strings.
</p>
<p>
<code class="calibre2">yLineBias</code> is used in the base graphics system in <code class="calibre2">axis()</code> and <code class="calibre2">mtext()</code> to provide a default for their ‘padj’ argument.
</p>
<hr />
<p>
<a href="" id="Conventions"></a> <a href="" id="Conventions-1"></a>
</p>
<h4 id="conventions" class="subsection">
6.1.4 Conventions
</h4>
<p>
The aim is to make the (default) output from graphics devices as similar as possible. Generally people follow the model of the <code class="calibre2">postscript</code> and <code class="calibre2">pdf</code> devices (which share most of their internal code).
</p>
<p>
The following conventions have become established:
</p>
<ul>
<li>
The default size of a device should be 7 inches square.
</li>
<li>
There should be a ‘pointsize’ argument which defaults to 12, and it should give the pointsize in big points (1/72 inch). How exactly this is interpreted is font-specific, but it should use a font which works with lines packed 1/6 inch apart, and looks good with lines 1/5 inch apart (that is with 2pt leading).
</li>
<li>
The default font family should be a sans serif font, e.g Helvetica or similar (e.g. Arial on Windows).
</li>
<li>
<code class="calibre2">lwd = 1</code> should correspond to a line width of 1/96 inch. This will be a problem with pixel-based devices, and generally there is a minimum line width of 1 pixel (although this may not be appropriate where anti-aliasing of lines is used, and <code class="calibre2">cairo</code> prefers a minimum of 2 pixels).
</li>
<li>
Even very small circles should be visible, e.g. by using a minimum radius of 1 pixel or replacing very small circles by a single filled pixel.
</li>
<li>
How RGB colour values will be interpreted should be documented, and preferably be sRGB.
</li>
<li>
The help page should describe its policy on these conventions.
</li>
</ul>
<p>
These conventions are less clear-cut for bitmap devices, especially where the bitmap format does not have a design resolution.
</p>
<p>
The interpretation of the line texture (<code class="calibre2">par(“lty”</code>) is described in the header GraphicsEngine.h and in the help for <code class="calibre2">par</code>: note that the ‘scale’ of the pattern should be proportional to the line width (at least for widths above the default).
</p>
<hr />
<p>
<a href="" id="g_t_0027Mode_0027"></a> <a href="" id="g_t_0060Mode_0027"></a>
</p>
<h4 id="mode" class="subsection">
6.1.5 ‘Mode’
</h4>
<p>
One of the device callbacks is a function <code class="calibre2">mode</code>, documented in the header as
</p>
<div class="example">
<pre class="example1"><code>     * device_Mode is called whenever the graphics engine
     * starts drawing (mode=1) or stops drawing (mode=0)
     * GMode (in graphics.c) also says that
     * mode = 2 (graphical input on) exists.
     * The device is not required to do anything</code></pre>
</div>
<p>
Since <code class="calibre2">mode = 2</code> has only recently been documented at device level. It could be used to change the graphics cursor, but devices currently do that in the <code class="calibre2">locator</code> callback. (In base graphics the mode is set for the duration of a <code class="calibre2">locator</code> call, but if <code class="calibre2">type != “n”</code> is switched back for each point whilst annotation is being done.)
</p>
<p>
Many devices do indeed do nothing on this call, but some screen devices ensure that drawing is flushed to the screen when called with <code class="calibre2">mode = 0</code>. It is tempting to use it for some sort of buffering, but note that ‘drawing’ is interpreted at quite a low level and a typical single figure will stop and start drawing many times. The buffering introduced in the <code class="calibre2">X11()</code> device makes use of <code class="calibre2">mode = 0</code> to indicate activity: it updates the screen after <em>ca</em> 100ms of inactivity.
</p>
<p>
This callback need not be supplied if it does nothing.
</p>
<hr />
<p>
<a href="" id="Graphics-events"></a> <a href="" id="Graphics-events-1"></a>
</p>
<h4 id="graphics-events" class="subsection">
6.1.6 Graphics events
</h4>
<p>
Graphics devices may be designed to handle user interaction: not all are.
</p>
<p>
Users may use <code class="calibre2">grDevices::setGraphicsEventEnv</code> to set the <code class="calibre2">eventEnv</code> environment in the device driver to hold event handlers. When the user calls <code class="calibre2">grDevices::getGraphicsEvent</code>, R will take three steps. First, it sets the device driver member <code class="calibre2">gettingEvent</code> to <code class="calibre2">true</code> for each device with a non-<code class="calibre2">NULL</code> <code class="calibre2">eventEnv</code> entry, and calls <code class="calibre2">initEvent(dd, true)</code> if the callback is defined. It then enters an event loop. Each time through the loop R will process events once, then check whether any device has set the <code class="calibre2">result</code> member of <code class="calibre2">eventEnv</code> to a non-<code class="calibre2">NULL</code> value, and will save the first such value found to be returned. C functions <code class="calibre2">doMouseEvent</code> and <code class="calibre2">doKeybd</code> are provided to call the R event handlers <code class="calibre2">onMouseDown</code>, <code class="calibre2">onMouseMove</code>, <code class="calibre2">onMouseUp</code>, and <code class="calibre2">onKeybd</code> and set <code class="calibre2">eventEnv$result</code> during this step. Finally, <code class="calibre2">initEvent</code> is called again with <code class="calibre2">init=false</code> to inform the devices that the loop is done, and the result is returned to the user.
</p>
<hr />
<p>
<a href="" id="Specific-devices"></a> <a href="" id="Specific-devices-1"></a>
</p>
<h4 id="specific-devices" class="subsection">
6.1.7 Specific devices
</h4>
<p>
Specific devices are mostly documented by comments in their sources, although for devices of many years’ standing those comments can be in need of updating. This subsection is a repository of notes on design decisions.
</p>
<hr />
<p>
<a href="" id="X11_0028_0029"></a> <a href="" id="X11_0028_0029-1"></a>
</p>
<h4 id="x11" class="subsection">
6.1.7.1 X11()
</h4>
<p>
The <code class="calibre2">X11(type=“Xlib”)</code> device dates back to the mid 1990’s and was written then in <code class="calibre2">Xlib</code>, the most basic X11 toolkit. It has since optionally made use of a few features from other toolkits: <code class="calibre2">libXt</code> is used to read X11 resources, and <code class="calibre2">libXmu</code> is used in the handling of clipboard selections.
</p>
<p>
Using basic <code class="calibre2">Xlib</code> code makes drawing fast, but is limiting. There is no support of translucent colours (that came in the <code class="calibre2">Xrender</code> toolkit of 2000) nor for rotated text (which R implements by rendering text to a bitmap and rotating the latter).
</p>
<p>
The hinting for the X11 window asks for backing store to be used, and some windows managers may use it to handle repaints, but it seems that most repainting is done by replaying the display list (and here the fast drawing is very helpful).
</p>
<p>
There are perennial problems with finding fonts. Many users fail to realize that fonts are a function of the X server and not of the machine that R is running on. After many difficulties, R tries first to find the nearest size match in the sizes provided for Adobe fonts in the standard 75dpi and 100dpi X11 font packages—even that will fail to work when users of near-100dpi screens have only the 75dpi set installed. The 75dpi set allows sizes down to 6 points on a 100dpi screen, but some users do try to use smaller sizes and even 6 and 8 point bitmapped fonts do not look good.
</p>
<p>
Introduction of UTF-8 locales has caused another wave of difficulties. X11 has very few genuine UTF-8 fonts, and produces composite fontsets for the <code class="calibre2">iso10646-1</code> encoding. Unfortunately these seem to have low coverage apart from a few monospaced fonts in a few sizes (which are not suitable for graph annotation), and where glyphs are missing what is plotted is often quite unsatisfactory.
</p>
<p>
The current approach is to make use of more modern toolkits, namely <code class="calibre2">cairo</code> for rendering and <code class="calibre2">Pango</code> for font management—because these are associated with <code class="calibre2">Gtk+2</code> they are widely available. Cairo supports translucent colours and alpha-blending (<em>via</em> <code class="calibre2">Xrender</code>), and anti-aliasing for the display of lines and text. Pango’s font management is based on <code class="calibre2">fontconfig</code> and somewhat mysterious, but it seems mainly to use Type 1 and TrueType fonts on the machine running R and send grayscale bitmaps to cairo.
</p>
<hr />
<p>
<a href="" id="windows_0028_0029"></a> <a href="" id="windows_0028_0029-1"></a>
</p>
<h4 id="windows" class="subsection">
6.1.7.2 windows()
</h4>
<p>
The <code class="calibre2">windows()</code> device is a family of devices: it supports plotting to Windows (enhanced) metafiles, <code class="calibre2">BMP</code>, <code class="calibre2">JPEG</code>, <code class="calibre2">PNG</code> and <code class="calibre2">TIFF</code> files as well as to Windows printers.
</p>
<p>
In most of these cases the primary plotting is to a bitmap: this is used for the (default) buffering of the screen device, which also enables the current plot to be saved to BMP, JPEG, PNG or TIFF (it is the internal bitmap which is copied to the file in the appropriate format).
</p>
<p>
The device units are pixels (logical ones on a metafile device).
</p>
<p>
The code was originally written by Guido Masarotto with extensive use of macros, which can make it hard to disentangle.
</p>
<p>
For a screen device, <code class="calibre2">xd-&gt;gawin</code> is the canvas of the screen, and <code class="calibre2">xd-&gt;bm</code> is the off-screen bitmap. So macro <code class="calibre2">DRAW</code> arranges to plot to <code class="calibre2">xd-&gt;bm</code>, and if buffering is off, also to <code class="calibre2">xd-&gt;gawin</code>. For all other device, <code class="calibre2">xd-&gt;gawin</code> is the canvas, a bitmap for the <code class="calibre2">jpeg()</code> and <code class="calibre2">png()</code> device, and an internal representation of a Windows metafile for the <code class="calibre2">win.metafile()</code> and <code class="calibre2">win.print</code> device. Since ‘plotting’ is done by Windows GDI calls to the appropriate canvas, its precise nature is hidden by the GDI system.
</p>
<p>
Buffering on the screen device is achieved by running a timer, which when it fires copies the internal bitmap to the screen. This is set to fire every 500ms (by default) and is reset to 100ms after plotting activity.
</p>
<p>
Repaint events are handled by copying the internal bitmap to the screen canvas (and then reinitializing the timer), unless there has been a resize. Resizes are handled by replaying the display list: this might not be necessary if a fixed canvas with scrollbars is being used, but that is the least popular of the three forms of resizing.
</p>
<p>
Text on the device has moved to ‘Unicode’ (UCS-2) in recent years. UTF-8 is requested (<code class="calibre2">hasTextUTF8 = TRUE</code>) for standard text, and converted to UCS-2 in the plotting functions in file src/extra/graphapp/gdraw.c. However, GDI has no support for Unicode symbol fonts, and symbols are handled in Adobe Symbol encoding.
</p>
<p>
There is support for translucent colours (with alpha channel between 0 and 255) was introduced on the screen device and bitmap devices.<a href="concept-index.html#FOOT20" id="DOCF20"><sup>20</sup></a> This is done by drawing on a further internal bitmap, <code class="calibre2">xd-&gt;bm2</code>, in the opaque version of the colour then alpha-blending that bitmap to <code class="calibre2">xd-&gt;bm</code>. The alpha-blending routine is in a separate DLL, msimg32.dll, which is loaded on first use. As small a rectangular region as reasonably possible is alpha-blended (this is rectangle <code class="calibre2">r</code> in the code), but things like mitre joins make estimation of a tight bounding box too much work for lines and polygonal boundaries. Translucent-coloured lines are not common, and the performance seems acceptable.
</p>
<p>
The support for a transparent background in <code class="calibre2">png()</code> predates full alpha-channel support in <code class="calibre2">libpng</code> (let alone in PNG viewers), so makes use of the limited transparency support in earlier versions of PNG. Where 24-bit colour is used, this is done by marking a single colour to be rendered as transparent. R chose ‘#fdfefd’, and uses this as the background colour (in <code class="calibre2">GA_NewPage</code> if the specified background colour is transparent (and all non-opaque background colours are treated as transparent). So this works by marking that colour in the PNG file, and viewers without transparency support see a slightly-off-white background, as if there were a near-white canvas. Where a palette is used in the PNG file (if less than 256 colours were used) then this colour is recorded with full transparency and the remaining colours as opaque. If 32-bit colour were available then we could add a full alpha channel, but this is dependent on the graphics hardware and undocumented properties of GDI.
</p>
<hr />
<p>
<a href="" id="Colours"></a> <a href="" id="Colours-1"></a>
</p>
<h3 id="colours" class="section">
6.2 Colours
</h3>
<p>
Devices receive colours as a <code class="calibre2">typedef</code> <code class="calibre2">rcolor</code> (an <code class="calibre2">unsigned int</code>) defined in the header R_ext/GraphicsEngine.h). The 4 bytes are <em>R</em> ,<em>G</em>, <em>B</em> and <em>alpha</em> from least to most significant. So each of RGB has 256 levels of luminosity from 0 to 255. The alpha byte represents opacity, so value 255 is fully opaque and 0 fully transparent: many but not all devices handle semi-transparent colours.
</p>
<p>
Colors can be created in C via the macro <code class="calibre2">R_RGBA</code>, and a set of macros are defined in R_ext/GraphicsDevice.h to extract the various components.
</p>
<p>
Colours in the base graphics system were originally adopted from S (and before that the GRZ library from Bell Labs), with the concept of a (variable-sized) palette of colours referenced by numbers ‘1…N’ plus ‘0’ (the background colour of the current device). R introduced the idea of referring to colours by character strings, either in the forms ‘#RRGGBB’ or ‘#RRGGBBAA’ (representing the bytes in hex) as given by function <code class="calibre2">rgb()</code> or via names: the 657 known names are given in the character vector <code class="calibre2">colors</code> and in a table in file colors.c in package <strong>grDevices</strong>. Note that semi-transparent colours are not ‘premultiplied’, so 50% transparent white is ‘#ffffff80’.
</p>
<p>
Integer or character <code class="calibre2">NA</code> colours are mapped internally to transparent white, as is the character string <code class="calibre2">“NA”</code>.
</p>
<p>
Negative colour numbers are an error. Colours greater than ‘N’ are wrapped around, so that for example with the default palette of size 8, colour ‘10’ is colour ‘2’ in the palette.
</p>
<p>
Integer colours have been used more widely than the base graphics sub-system, as they are supported by package <strong>grid</strong> and hence by <a href="https://CRAN.R-project.org/package=lattice"><strong>lattice</strong></a> and <a href="https://CRAN.R-project.org/package=ggplot2"><strong>ggplot2</strong></a>. (They are also used by package <a href="https://CRAN.R-project.org/package=rgl"><strong>rgl</strong></a>.) <strong>grid</strong> did re-define colour ‘0’ to be transparent white, but <a href="https://CRAN.R-project.org/package=rgl"><strong>rgl</strong></a> used <code class="calibre2">col2rgb</code> and hence the background colour of base graphics.
</p>
<p>
Note that positive integer colours refer to the current palette and colour ‘0’ to the current device (and a device is opened if needs be). These are mapped to type <code class="calibre2">rcolor</code> at the time of use: this matters when re-playing the display list, e.g. when a device is resized or <code class="calibre2">dev.copy</code> is used. The palette should be thought of as per-session: it is stored in package <strong>grDevices</strong>.
</p>
<p>
The convention is that devices use the colorspace ‘sRGB’. This is an industry standard: it is used by Web browsers and JPEGs from all but high-end digital cameras. The interpretation is a matter for graphics devices and for code that manipulates colours, but not for the graphics engine or subsystems.
</p>
<p>
R uses a painting model similar to PostScript and PDF. This means that where shapes (circles, rectangles and polygons) can both be filled and have a stroked border, the fill should be painted first and then the border (or otherwise only half the border will be visible). Where both the fill and the border are semi-transparent there is some room for interpretation of the intention. Most devices first paint the fill and then the border, alpha-blending at each step. However, PDF does some automatic grouping of objects, and <em>when the fill and the border have the same alpha</em>, they are painted onto the same layer and then alpha-blended in one step. (See p. 569 of the PDF Reference Sixth Edition, version 1.7. Unfortunately, although this is what the PDF standard says should happen, it is not correctly implemented by some viewers.)
</p>
<p>
The mapping from colour numbers to type <code class="calibre2">rcolor</code> is primarily done by function <code class="calibre2">RGBpar3</code>: this is exported from the R binary but linked to code in package <strong>grDevices</strong>. The first argument is a <code class="calibre2">SEXP</code> pointing to a character, integer or double vector, and the second is the <code class="calibre2">rcolor</code> value for colour <code class="calibre2">0</code> (or <code class="calibre2">“0”</code>). C entry point <code class="calibre2">RGBpar</code> is a wrapper that takes <code class="calibre2">0</code> to be transparent white: it is often used to set colour defaults for devices. The R-level wrapper is <code class="calibre2">col2rgb</code>.
</p>
<p>
There is also <code class="calibre2">R_GE_str2col</code> which takes a C string and converts to type <code class="calibre2">rcolor</code>: <code class="calibre2">“0’</code> is converted to transparent white.
</p>
<p>
There is a R-level conversion of colours to ‘##RRGGBBAA’ by <code class="calibre2">image.default(useRaster = TRUE)</code>.
</p>
<p>
The other color-conversion entry point in the API is <code class="calibre2">name2col</code> which takes a colour name (a C string) and returns a value of type <code class="calibre2">rcolor</code>. This handles <code class="calibre2">“NA”</code>, <code class="calibre2">“transparent”</code> and the 657 colours known to the R function <code class="calibre2">colors()</code>.
</p>
<hr />
<p>
<a href="" id="Base-graphics"></a> <a href="" id="Base-graphics-1"></a>
</p>
<h3 id="base-graphics" class="section">
6.3 Base graphics
</h3>
<p>
The base graphics system was migrated to package <strong>graphics</strong> in R 3.0.0: it was previously implemented in files in src/main.
</p>
<p>
For historical reasons it is largely implemented in two layers. Files plot.c, <code class="calibre2">plot3d.c</code> and <code class="calibre2">par.c</code> contain the code for the around 30 <code class="calibre2">.External</code> calls that implement the basic graphics operations. This code then calls functions with names starting with <code class="calibre2">G</code> and declared in header Rgraphics.h in file graphics.c, which in turn call the graphics engine (whose functions almost all have names starting with <code class="calibre2">GE</code>).
</p>
<p>
A large part of the infrastructure of the base graphics subsystem are the graphics parameters (as set/read by <code class="calibre2">par()</code>). These are stored in a <code class="calibre2">GPar</code> structure declared in the private header Graphics.h. This structure has two variables (<code class="calibre2">state</code> and <code class="calibre2">valid</code>) tracking the state of the base subsystem on the device, and many variables recording the graphics parameters and functions of them.
</p>
<p>
The base system state is contained in <code class="calibre2">baseSystemState</code> structure defined in R_ext/GraphicsBase.h. This contains three <code class="calibre2">GPar</code> structures and a Boolean variable used to record if <code class="calibre2">plot.new()</code> (or <code class="calibre2">persp</code>) has been used successfully on the device.
</p>
<p>
The three copies of the <code class="calibre2">GPar</code> structure are used to store the current parameters (accessed via <code class="calibre2">gpptr</code>), the ‘device copy’ (accessed via <code class="calibre2">dpptr</code>) and space for a saved copy of the ‘device copy’ parameters. The current parameters are, clearly, those currently in use and are copied from the ‘device copy’ whenever <code class="calibre2">plot.new()</code> is called (whether or not that advances to the next ‘page’). The saved copy keeps the state when the device was last completely cleared (e.g. when <code class="calibre2">plot.new()</code> was called with <code class="calibre2">par(new=TRUE)</code>), and is used to replay the display list.
</p>
<p>
The separation is not completely clean: the ‘device copy’ is altered if a plot with log scale(s) is set up via <code class="calibre2">plot.window()</code>.
</p>
<p>
There is yet another copy of most of the graphics parameters in <code class="calibre2">static</code> variables in graphics.c which are used to preserve the current parameters across the processing of inline parameters in high-level graphics calls (handled by <code class="calibre2">ProcessInlinePars</code>).
</p>
<p>
Snapshots of the base subsystem record the ‘saved device copy’ of the <code class="calibre2">GPar</code> structure.
</p>
<hr />
<p>
<a href="" id="Arguments-and-parameters"></a> <a href="" id="Arguments-and-parameters-1"></a>
</p>
<h4 id="arguments-and-parameters" class="subsection">
6.3.1 Arguments and parameters
</h4>
<p>
There is an unfortunate confusion between some of the graphical parameters (as set by <code class="calibre2">par</code>) and arguments to base graphic functions of the same name. This description may help set the record straight.
</p>
<p>
Most of the high-level plotting functions accept graphical parameters as additional arguments, which are then often passed to lower-level functions if not already named arguments (which is the main source of confusion).
</p>
<p>
Graphical parameter <code class="calibre2">bg</code> is the background colour of the plot. Argument <code class="calibre2">bg</code> refers to the fill colour for the filled symbols <code class="calibre2">21</code> to <code class="calibre2">25</code>. It is an argument to the function <code class="calibre2">plot.xy</code>, but normally passed by the default method of <code class="calibre2">points</code>, often from a <code class="calibre2">plot</code> method.
</p>
<p>
Graphics parameters <code class="calibre2">cex</code>, <code class="calibre2">col</code>, <code class="calibre2">lty</code>, <code class="calibre2">lwd</code> and <code class="calibre2">pch</code> also appear as arguments of <code class="calibre2">plot.xy</code> and so are often passed as arguments from higher-level plot functions such as <code class="calibre2">lines</code>, <code class="calibre2">points</code> and <code class="calibre2">plot</code> methods. They appear as arguments of <code class="calibre2">legend</code>, <code class="calibre2">col</code>, <code class="calibre2">lty</code> and <code class="calibre2">lwd</code> are arguments of <code class="calibre2">arrows</code> and <code class="calibre2">segments</code>. When used as arguments they can be vectors, recycled to control the various lines, points and segments. When set a graphical parameters they set the default rendering: in addition <code class="calibre2">par(cex=)</code> sets the overall character expansion which subsequent calls (as arguments or on-line graphical parameters) multiply.
</p>
<p>
The handling of missing values differs in the two classes of uses. Generally these are errors when used in <code class="calibre2">par</code> but cause the corresponding element of the plot to be omitted when used as an element of a vector argument. Originally the interpretation of arguments was mainly left to the device, but nowadays some of this is pre-empted in the graphics engine (but for example the handling of <code class="calibre2">lwd = 0</code> remains device-specific, with some interpreting it as a ‘thinnest possible’ line).
</p>
<hr />
<p>
<a href="" id="Grid-graphics"></a> <a href="" id="Grid-graphics-1"></a>
</p>
<h3 id="grid-graphics" class="section">
6.4 Grid graphics
</h3>
<p>
[At least pointers to documentation.]
</p>
<hr />
<p>
<a href="" id="GUI-consoles"></a> <a href="" id="GUI-consoles-1"></a>
</p>
<div id="calibre_pb_15" class="calibre6">

</div>

</div>
            </section>

          </div>
        </div>
      </div>
<a href="files.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="gui-consoles.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
